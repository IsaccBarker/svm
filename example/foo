#include <svm_class.h>

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <errno.h>
#include <string.h>
#include <limits.h>

#include <svm_log.h>
#include <svm_bit.h>
#include <svm_globals.h>
#include <svm_class_file.h>
#include <svm_constant_pool.h>

void svm_start_virtual_machine(char* class_file) {
    log_trace("Reading class file.");
    FILE* f = svm_get_file_handle(class_file);
    size_t file_length = svm_get_file_size(f);
    unsigned char* data = svm_read_class_file(file_length, f);
    svm_class_representation* rep = malloc(file_length);

    display_class_hex(data, file_length);

    if (rep == NULL) {
        log_fatal("Failed to allocate memory to create class rep (%d): %s", file_length, strerror(errno));

        exit(EXIT_FAILURE);
    }

    memset(rep, 0, file_length);

    // Simple science.
    {
        rep->magic = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + (data[3]);
        if (rep->magic != 3405691582) {
            log_warn("Class's magic value is not CAFEBABE (3405691582). Possibly corrupted file? Continuing...");
        }

        rep->minor_ver = (data[4] << 8) + (data[5]);
        rep->major_ver = (data[6] << 8) + (data[7]);
    }

    // Constant pool
    {
        size_t offset = 0;

        // https://stackoverflow.com/questions/23674727/jvm-class-format-why-is-constant-pool-count-one-larger-than-it-should-be
        rep->constant_pool_count = (data[8] << 8) + (data[9]) - 1;
        rep->constant_pool = malloc(sizeof(cp_info) * rep->constant_pool_count);

        if (rep->constant_pool == NULL) {
            log_fatal("Failed to allocate memory for constant pool (%d): %s", sizeof(cp_info) * rep->constant_pool_count, strerror(errno));

            exit(EXIT_FAILURE);
        }

        for (int i = 0; i < rep->constant_pool_count; i++) {
            uint8_t tag = data[10+offset];
            uint16_t first = data[11+offset] << 8;
            size_t info_length;
            uint8_t* info;

            first += data[12+offset];
            first += 1;

            info_length = svm_constant_info_length(tag, first);
            offset += info_length;
            info = malloc(info_length * sizeof(uint8_t));

            for (size_t l = 0; l < info_length; l++) {
                if (l == info_length) {
                    info[l] = data[11+l+offset];
                }

                info[l] = data[11+l+offset] << ((info_length-l)*8);
            }

            cp_info cp_entry = {
                .tag = tag,
                .info_length = info_length,
                .info = info
            };

            rep->constant_pool[i] = cp_entry;
        }
    }

    svm_print_class_overview(rep);
}

void display_class_hex(unsigned char* data, size_t file_length) {
    log_debug("Hexadecimal notation:");
    printf("\t");
    for (unsigned int i = 0; i < file_length; i++) {
        printf("%02X", data[i]);

        if (i % 2 == 1) {
            printf(" ");
        }

        if (i % 16 == 15) {
            printf("\n\t");
        }
    }

    printf("\n");
}

void svm_print_class_overview(svm_class_representation* r) {
    log_debug("Magic                 : %08X", r->magic);
    log_debug("Minor Version         : (0x%04X, %d)", r->minor_ver, r->minor_ver);
    log_debug("Major Version         : (0x%04X, %d)", r->major_ver, r->major_ver);
    log_debug("Constant Pool Count   : %d", r->constant_pool_count);

    for (int i = 0; i < r->constant_pool_count; i++) {
        log_trace(svm_constant_info_as_string(r->constant_pool[i].tag));
    }

    log_debug("Access Flags          : %04X", r->access_flags);
    log_debug("This Class            : %d", r->this_class);
    log_debug("Super Class           : %d", r->super_class);
    log_debug("Interface Count       : %d", r->interfaces_count);

    log_debug("Fields Count          : %d", r->fields_count);

    log_debug("Methods Count         : %d", r->methods_count);

    log_debug("Attribute Count       : %d", r->attribute_count);
}

